// 09.BitOperator.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
    int Left = 1;
    int Right = 3;
    int Result = 0;

    // 0b00000000000000000000000000000001;
    // 0b11111111111111111111111111111110;
    // Not 비트 반전.
    Left = ~Left;

    Left = ~Left;

    // Left   0b00000000000000000000000000000001;
    // Right  0b00000000000000000000000000000011;
    // Result 0b00000000000000000000000000000001;

    // And
    // 두개의 비트는 비교해서
    // 둘다 1인 비트만 1인 결과를 리턴한다.
    Result = Left & Right;

    // Left   0b00000000000000000000000000000001;
    // Right  0b00000000000000000000000000000011;
    // Result 0b00000000000000000000000000000011;

    // Or
    // 두개의 비트를 비교해서
    // 둘중 하나만 1이어도 1
    Result = Left | Right;

    // Left   0b00000000000000000000000000000000;
    // Right  0b00000000000000000000000000000001;
    // Result 0b0000000000000000000000000000000?;

    // xor 베타적 논리합.
    // 둘이 다를때만 1의 결과가 나온다.
    Left = 0;
    Right = 0;
    Result = Left ^ Right;

    // 왼쪽 시프트 오른쪽 시프트
    //    값   시프트 카운트
    // 1 => 0b00000000000000000000000000000001;
    // 을 왼쪽으로 1칸 옮겨라;

    //                                    8421
    // 1 => 0b00000000000000000000000000000110;
    Left = 3 << 1;
    // 애초에 범위를 벗어나는 시프트 연산을 하지 않는게 좋다.
    Left = 1 << 35;

    Left = 1 >> 1;

    // 복합할당연산자
    // 축약형
    // 비 and 논리 제외
    // 왠만한 연산자는 다 축약이 됩니다.

    // 자기 자신을 메모리 대상으로 삼는 연산을 처리하게 됩니다.
    Left = 1;
    Left += Right; // == Left = Left + 1;
    Left -= Right; // == Left = Left + 1;
    Left /= Right; // == Left = Left + 1;
    Left *= Right; // == Left = Left + 1;
    Left %= 1; // == Left = Left + 1;
    Left <<= Right; // == Left = Left + 1;
    Left >>= 1; // == Left = Left + 1;
    Left &= 1; // == Left = Left + 1;
    Left |= 1; // == Left = Left + 1;
    Left |= 1; // == Left = Left + 1;

}
